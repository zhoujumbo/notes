适于内存：
1、二叉排序树(BS树)
  定义：* (1) 若左子树不为空，则左子树上所有结点的值均小于根结点的值
	* (2) 若右子树不为空，则右子树上所有节点的值均大于根结点的值
	* (3) 左右子树也都是二叉排序树
  (-) 左右子树分布均匀：类似于二分查找，时间复杂度：O(logn)
  (-) 左右子树分布不均匀：类似顺序查找，时间复杂度：O(n)

2、平衡二叉树(AVL树)
  定义：* (1) 二叉树中任意结点的左右子树深度之差的绝对值小于等于1
	* (2) 即该结点的平衡因子(平衡度)只可能是: -1、0、1
	* (3) 左右子树也都是平衡二叉树
  (-) 在平衡二叉树上插入或是删除结点后，可能使得平衡度大于1而失去平衡，
      因此有以下四种调整平衡措施：
      LL:单向右旋  RR:单向左旋  LR:先左后右  RL:先右后左
  (-) AVL树优点：结构更加平衡，提高查找速度。适用于查找操作。
  (-) AVL树缺点：插入和删除操作复杂(需要调整平衡)，因此不适于插入和删除操作。
  (-) 时间复杂度：O(logn)

适于外存-内存交互：
3、B树
  B树是一种平衡的多路查找树， 2-3树和2-3-4树都是B树的特例。
  结点最大的孩子数目称为B树的阶(order) ，因此，2-3树是3阶B树， 2-3-4树是4阶B树。

  一个m 阶的B树具有如下属性:
  • 如果根结点不是叶结点，则其至少有两棵子树.
  • 每一个非根的分支结点都有k-l个元素和k个孩子，每一个叶子结点n都有k-l个元素。
  • 所有叶子结点都位于同一层次。
  • 所有分支结点包含数据信息：(关键字个数n，关键字Ki，指向子树根结点指针Ai)
  • 例如：(3, A0, K1, A1, K2, A2, K3, A3) 

4、B+树
  一棵m 阶的B+树和m 阶的8 树的差异在于:
  • 有n 棵子树的结点中包含有n 个关键字;
  • 所有的叶子结点包含全部关键字的信息，及指向含这些关键字记录的指针，
    叶子结点本身依关键字的大小自小而大顺序链接;
  • 所有分支结点可以看成是索引，结点中仅含有其子树中的最大(或最小)关键字。

这样的数据结构最大的好处就在于，如果是要随机查找，我们就从根结点出发，
与B 树的查找方式相同，只不过即使在分支结点找到了待查找的关键字，也只是用
来索引的，不能提供实际记录的访问，还是需要到达包含此关键字的终端结点。

如果我们是需要从最小关键字进行从小到大的顺序查找，我们就可以从最左侧的
叶子结点出发，不经过分支结点，而是延着指向下一叶子的指针就可遍历所有的关
键字。


5、红黑树
  对称二叉B树，自平衡的二叉查找树。 时间复杂度：O(logN)
性质一：节点是红色或者是黑色； 
性质二：根节点是黑色； 根节点总是黑色的。它不能为红 
性质三：每个叶节点（NIL或空节点）是黑色
性质四：每个红色节点的两个子节点都是黑色的（也就是说不存在两个连续的红色节点）
就是连续的两个节点不能是连续的红色，连续的两个节点的意思就是父节点与子节点不能是连续的红色
性质五：从任一节点到其没个叶节点的所有路径都包含相同数目的黑色节点

